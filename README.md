# GeneratePresetImpl.generate()

## 1. Сортировка

Сортировка имеет сложность `O(N*log(N))`, где N - количество типов юнитов в unitList.

## 2. Генерация и перемешивание координат

Заполнение списка доступных координат имеет сложность `O(W*H)`, где W - ширина зоны (3), H - высота зона (21), `O(3*21) = O(1)`.

Перемешивание коллекции с помощью Collection.shuffle() также имеет сложность `O(W*H) = O(1)`.

## 3. Добавление юнитов

Добавление юнитов в армию имеет сложность `O(M*N)`, где N - количество типов юнитов, M - максимальное количество юнитов одного типа (11), `O(11*N) = O(N)`.

## Итог

Таким образом, итоговая сложность будет складываться из `O(N*log(N)) + O(1) + O(N)` = `O(N*log(N))`, где N - количество типов юнитов.

---

# SimulateBattleImpl.simulate()

## 1. Получение списка живых юнитов

Получение списка живых юнитов имеет сложность `O(N)`, где N - количество юнитов в армии.

## 2. Создание и наполнение очередей

Добавление всех юнитов в очередь с приоритетом имеет сложность `O(N*log(N))`, где N - текущий размер списка юнитов.

## 3. Переход по очереди и атака

Повторяется для каждой очереди, пока она не опустеет, каждое извлечение из очереди с приоритетом имеет сложность `O(log(N))`.

В худшем случае это будет `O(N*log(N))` на каждую армию за один полный раунд.

## Итог

В среднем можно ожидать, что потребуется несколько раундов, чтобы сократить размеры армий до завершения симуляции. В случае полного уничтожения одной армии потребуется по крайней мере `O(N)` атак, пока одна из армий не будет полностью уничтожена.

Таким образом, общая сложность за все раунды может быть оценена как `O(N^2*log(N))`.

---

# SuitableForAttackUnitsFinderImpl.getSuitableUnits()

Поиск подходящих юнитов имеет сложность `O(N*M)`, где N - количество юнитов в ряду, M - количество рядов, где могут располагаться юниты (3), `O(3*N) = O(N)`.

---

# UnitTargetPathFinderImpl.getTargetPath()

## 1. Инициализация

Инициализируются массивов `distances`, `visited` и `predecessors` имеет сложность `O(W*H)`.

## 2. Формирование координат занятых юнитами позиций

Вычисление множества координат занятых юнитами позиций имеет сложность `O(N)`, где N - количество юнитов в existingUnitList.

## 3. Аалгоритм Дейкстры

Для обработки узлов в порядке увеличения их стоимости используется очередь с приоритетом, которая позволяет выполнять операции добавления и извлечения за `O(log(N))`, где N - текущее количество элементов в очереди.

Для каждой клетки сетки в худшем случае добавляется связь со всеми ее соседями (4) и каждый узел помещается в очередь хотя бы один раз. Следовательно, получение из очереди и добавление всех соседей выполняются за `O(W*H*log(W*H)`.

## 4. Формирование пути

После завершения обработки все узлы находятся в матрице `predecessors` и алгоритм восстанавливает путь от целевой точки, двигаясь назад к начальной. Сложность этого действия ограничена количеством узлов и равна `O(W*H)`.

## Итог

Наиболее сложной операцией является обработка очереди с приоритетом. Таким образом весь алгоритм имеет сложность `O(W*H*log(W*H))`.